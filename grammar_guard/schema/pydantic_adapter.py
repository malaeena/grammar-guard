"""
Pydantic model adapter - converts Pydantic models to JSON Schema.

This module provides conversion from Pydantic BaseModel classes to JSON Schema
dictionaries, allowing users to define schemas using Pydantic's convenient
Python-native syntax.

Pydantic v2 has excellent JSON Schema generation built-in via model_json_schema(),
so we primarily wrap that functionality with any necessary adaptations.

Usage:
    ```python
    from pydantic import BaseModel, Field
    from grammar_guard.schema import pydantic_to_schema

    class User(BaseModel):
        name: str = Field(min_length=3, max_length=50)
        age: int = Field(ge=0, le=150)
        email: str

    schema = pydantic_to_schema(User)
    # Returns JSON Schema dict equivalent to Pydantic model
    ```
"""

from typing import Any, Dict, Type

try:
    from pydantic import BaseModel
    PYDANTIC_AVAILABLE = True
except ImportError:
    PYDANTIC_AVAILABLE = False
    BaseModel = None  # type: ignore


def pydantic_to_schema(model: Type[BaseModel]) -> Dict[str, Any]:
    """
    Convert a Pydantic BaseModel class to a JSON Schema dictionary.

    Args:
        model: Pydantic BaseModel class (not instance)

    Returns:
        Dict: JSON Schema representation of the model

    Raises:
        ImportError: If Pydantic is not installed
        TypeError: If model is not a Pydantic BaseModel class

    Example:
        ```python
        from pydantic import BaseModel

        class Address(BaseModel):
            street: str
            city: str
            zipcode: str

        class User(BaseModel):
            name: str
            age: int
            address: Address

        schema = pydantic_to_schema(User)
        # schema = {
        #     "type": "object",
        #     "properties": {
        #         "name": {"type": "string"},
        #         "age": {"type": "integer"},
        #         "address": {
        #             "type": "object",
        #             "properties": {
        #                 "street": {"type": "string"},
        #                 "city": {"type": "string"},
        #                 "zipcode": {"type": "string"}
        #             },
        #             "required": ["street", "city", "zipcode"]
        #         }
        #     },
        #     "required": ["name", "age", "address"]
        # }
        ```
    """
    if not PYDANTIC_AVAILABLE:
        raise ImportError(
            "Pydantic is not installed. Install it with: pip install pydantic>=2.5"
        )

    if not isinstance(model, type) or not issubclass(model, BaseModel):
        raise TypeError(
            f"Expected Pydantic BaseModel class, got {type(model)}. "
            "Pass the class itself, not an instance."
        )

    # Use Pydantic v2's built-in JSON Schema generation
    schema = model.model_json_schema()

    # Post-process to ensure compatibility with our parser
    schema = _post_process_schema(schema)

    return schema


def _post_process_schema(schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Post-process Pydantic-generated JSON Schema for compatibility.

    Pydantic v2 generates JSON Schema Draft 2020-12 compliant schemas,
    but we need to ensure they're compatible with our parser.

    Args:
        schema: JSON Schema generated by Pydantic

    Returns:
        Dict: Post-processed schema

    Transformations:
    - Remove $defs and inline referenced schemas (we don't support $ref in MVP)
    - Convert prefixItems to items if present
    - Simplify complex anyOf/allOf if possible
    """
    schema = schema.copy()

    # Remove unsupported keys
    schema.pop("$defs", None)
    schema.pop("$schema", None)
    schema.pop("title", None)
    schema.pop("description", None)

    # Recursively process nested schemas
    if "properties" in schema:
        schema["properties"] = {
            k: _post_process_schema(v) for k, v in schema["properties"].items()
        }

    if "items" in schema:
        if isinstance(schema["items"], dict):
            schema["items"] = _post_process_schema(schema["items"])
        elif isinstance(schema["items"], list):
            # prefixItems - not supported, just use first item type
            schema["items"] = _post_process_schema(schema["items"][0]) if schema["items"] else {}

    if "anyOf" in schema:
        schema["anyOf"] = [_post_process_schema(s) for s in schema["anyOf"]]

    if "oneOf" in schema:
        schema["oneOf"] = [_post_process_schema(s) for s in schema["oneOf"]]

    # Handle allOf by merging (simple case only)
    if "allOf" in schema:
        # For MVP, we'll just take the most restrictive schema
        # Proper allOf merging is complex
        merged = {}
        for sub_schema in schema["allOf"]:
            merged.update(_post_process_schema(sub_schema))
        schema.update(merged)
        del schema["allOf"]

    return schema


def is_pydantic_model(obj: Any) -> bool:
    """
    Check if an object is a Pydantic BaseModel class.

    Args:
        obj: Object to check

    Returns:
        bool: True if obj is a Pydantic BaseModel class

    Example:
        ```python
        from pydantic import BaseModel

        class User(BaseModel):
            name: str

        assert is_pydantic_model(User) == True
        assert is_pydantic_model(User(name="test")) == False
        assert is_pydantic_model(dict) == False
        ```
    """
    if not PYDANTIC_AVAILABLE:
        return False

    return isinstance(obj, type) and issubclass(obj, BaseModel)


def extract_field_info(model: Type[BaseModel]) -> Dict[str, Dict[str, Any]]:
    """
    Extract field information from a Pydantic model.

    This provides detailed information about each field including:
    - Type
    - Whether it's required
    - Default value
    - Validation constraints

    Args:
        model: Pydantic BaseModel class

    Returns:
        Dict: Mapping of field names to field information

    Example:
        ```python
        from pydantic import BaseModel, Field

        class User(BaseModel):
            name: str = Field(min_length=3)
            age: int = Field(default=0, ge=0)

        info = extract_field_info(User)
        # info = {
        #     "name": {
        #         "type": "string",
        #         "required": True,
        #         "constraints": {"minLength": 3}
        #     },
        #     "age": {
        #         "type": "integer",
        #         "required": False,
        #         "default": 0,
        #         "constraints": {"minimum": 0}
        #     }
        # }
        ```
    """
    if not PYDANTIC_AVAILABLE:
        raise ImportError("Pydantic is not installed")

    if not isinstance(model, type) or not issubclass(model, BaseModel):
        raise TypeError("Expected Pydantic BaseModel class")

    field_info = {}

    for field_name, field in model.model_fields.items():
        info = {
            "required": field.is_required(),
            "default": field.default if field.default is not None else None,
            "constraints": {}
        }

        # Extract constraints from field metadata
        if field.metadata:
            for constraint in field.metadata:
                if hasattr(constraint, "__dict__"):
                    info["constraints"].update(constraint.__dict__)

        field_info[field_name] = info

    return field_info
